/**
 * @formspec/decorators
 *
 * Decorators for FormSpec form definitions.
 *
 * These decorators work in two modes:
 *
 * 1. **Build-time (CLI generate)**: The FormSpec CLI reads decorators through
 *    static analysis and generates JSON Schema + UI Schema files directly.
 *
 * 2. **Runtime (with CLI codegen)**: Run `formspec codegen` to generate a type
 *    metadata file, then use `toFormSpec()` to generate specs at runtime.
 *
 * @example
 * ```typescript
 * import { Label, Min, Max, EnumOptions, toFormSpec } from '@formspec/decorators';
 *
 * class UserForm {
 *   @Label("Full Name")
 *   name!: string;
 *
 *   @Label("Age")
 *   @Min(18)
 *   @Max(120)
 *   age?: number;
 *
 *   @Label("Country")
 *   @EnumOptions([
 *     { id: "us", label: "United States" },
 *     { id: "ca", label: "Canada" }
 *   ])
 *   country!: "us" | "ca";
 * }
 *
 * // After running: formspec codegen ./forms.ts -o ./__formspec_types__.ts
 * // Import the generated file and use toFormSpec:
 * import './__formspec_types__';
 * const spec = toFormSpec(UserForm);
 * ```
 */

// =============================================================================
// Types
// =============================================================================

/** Type for property decorator */
type PropertyDecorator = (target: object, propertyKey: string) => void;

/** Type for enum option - can be a simple string or an object with id/label */
export type EnumOptionValue = string | { id: string; label: string };

/**
 * Input type for @EnumOptions decorator.
 * Accepts either an array of options or a record mapping ids to labels.
 */
export type EnumOptionsInput = EnumOptionValue[] | Record<string, string>;

/** Type for conditional visibility condition */
export interface ShowWhenCondition {
  field: string;
  value: unknown;
}

/** Decorator metadata stored at runtime */
export interface FieldDecoratorMetadata {
  label?: string;
  placeholder?: string;
  description?: string;
  min?: number;
  max?: number;
  step?: number;
  minLength?: number;
  maxLength?: number;
  minItems?: number;
  maxItems?: number;
  pattern?: string;
  options?: EnumOptionValue[];
  showWhen?: ShowWhenCondition;
  group?: string;
}

/**
 * Type metadata emitted by the CLI codegen command.
 *
 * Describes the runtime type information for a field that TypeScript
 * normally erases. Generated by `formspec codegen` from static analysis.
 */
export interface TypeMetadata {
  /** Base type: "string", "number", "boolean", "enum", "array", "object", "unknown" */
  type: string;
  /** For enum types, the possible literal values */
  values?: unknown[];
  /** For array types, metadata about the array element type */
  itemType?: TypeMetadata;
  /** For object types, metadata about each property */
  properties?: Record<string, TypeMetadata>;
  /** Whether the field accepts null */
  nullable?: boolean;
  /** Whether the field is optional (T | undefined or ?: modifier) */
  optional?: boolean;
}

/**
 * FormSpec field element representation.
 *
 * This is the internal format used by FormSpec to represent form fields.
 * Generated from decorated classes via `toFormSpec()` or `buildFormSchemas()`.
 */
export interface FormSpecField {
  /** Field type: "text", "number", "boolean", "enum", "array", "object" */
  _field: string;
  /** Unique field identifier (property name) */
  id: string;
  /** Display label for the field */
  label?: string;
  /** Placeholder text for input fields */
  placeholder?: string;
  /** Help text or description */
  description?: string;
  /** Whether the field is required (non-optional) */
  required?: boolean;
  /** Minimum value for number fields */
  min?: number;
  /** Maximum value for number fields */
  max?: number;
  /** Step increment for number fields */
  step?: number;
  /** Minimum character length for text fields */
  minLength?: number;
  /** Maximum character length for text fields */
  maxLength?: number;
  /** Minimum items for array fields */
  minItems?: number;
  /** Maximum items for array fields */
  maxItems?: number;
  /** Regex pattern for text validation */
  pattern?: string;
  /** Enum options (strings or {id, label} objects) */
  options?: EnumOptionValue[];
  /** Conditional visibility rule */
  showWhen?: ShowWhenCondition;
  /** Group name for field grouping */
  group?: string;
  /** Nested fields for object/array types */
  fields?: FormSpecField[];
}

/** FormSpec output (elements only, for backwards compatibility) */
export interface FormSpecOutput {
  elements: FormSpecField[];
}

/**
 * JSON Schema type (subset of JSON Schema draft-07).
 *
 * Used for validation schema output from `buildFormSchemas()`.
 * Only includes properties used by FormSpec; not a complete JSON Schema type.
 *
 * @see https://json-schema.org/draft-07/schema
 */
export interface JSONSchema7 {
  /** JSON Schema dialect identifier */
  $schema?: string;
  /** Data type: "string", "number", "boolean", "object", "array" */
  type?: string;
  /** Object property schemas (for type: "object") */
  properties?: Record<string, JSONSchema7>;
  /** Required property names (for type: "object") */
  required?: string[];
  /** Human-readable title (from @Label decorator) */
  title?: string;
  /** Minimum numeric value (from @Min decorator) */
  minimum?: number;
  /** Maximum numeric value (from @Max decorator) */
  maximum?: number;
  /** Minimum string length (from @MinLength decorator) */
  minLength?: number;
  /** Maximum string length (from @MaxLength decorator) */
  maxLength?: number;
  /** Minimum array items (from @MinItems decorator) */
  minItems?: number;
  /** Maximum array items (from @MaxItems decorator) */
  maxItems?: number;
  /** Regex validation pattern (from @Pattern decorator) */
  pattern?: string;
  /** Enum values (for simple string enums) */
  enum?: unknown[];
  /** Enum with labels using oneOf/const pattern */
  oneOf?: { const: unknown; title?: string }[];
  /** Array item schema (for type: "array") */
  items?: JSONSchema7;
}

/**
 * UI Schema element types for JSON Forms.
 */
export interface UISchemaElement {
  type: string;
  elements?: UISchemaElement[];
  scope?: string;
  label?: string;
  rule?: UISchemaRule;
}

/**
 * UI Schema rule for conditional visibility.
 */
export interface UISchemaRule {
  effect: "SHOW" | "HIDE" | "ENABLE" | "DISABLE";
  condition: {
    scope: string;
    schema: Record<string, unknown>;
  };
}

/**
 * Result of building form schemas.
 * Matches the return type of `buildFormSchemas` from @formspec/build.
 */
export interface BuildResult {
  /** JSON Schema for validation */
  readonly jsonSchema: JSONSchema7;
  /** JSON Forms UI Schema for rendering */
  readonly uiSchema: UISchemaElement;
}

// =============================================================================
// Runtime Metadata Storage
// =============================================================================

/**
 * Storage for decorator metadata, keyed by constructor.
 * This is a regular Map (not WeakMap) since class constructors
 * live for the lifetime of the application.
 */
const decoratorMetadata = new Map<
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  new (...args: any[]) => any,
  Map<string, FieldDecoratorMetadata>
>();

/**
 * Gets or creates the metadata map for a class constructor.
 */
function getFieldMetadata(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ctor: new (...args: any[]) => any,
  propertyKey: string
): FieldDecoratorMetadata {
  if (!decoratorMetadata.has(ctor)) {
    decoratorMetadata.set(ctor, new Map());
  }
  // Safe to use non-null assertion: we just created the map if it didn't exist
  const classMetadata = decoratorMetadata.get(ctor);
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  if (!classMetadata!.has(propertyKey)) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    classMetadata!.set(propertyKey, {});
  }
  // Safe to use non-null assertion: we just created the metadata if it didn't exist
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  return classMetadata!.get(propertyKey)!;
}

// =============================================================================
// Field Metadata Decorators
// =============================================================================

/**
 * Sets the display label for a field.
 *
 * @param text - The label text to display
 * @example
 * ```typescript
 * @Label("Email Address")
 * email!: string;
 * ```
 */
export function Label(text: string): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).label = text;
  };
}

/**
 * Sets placeholder text for input fields.
 *
 * @param text - The placeholder text
 * @example
 * ```typescript
 * @Placeholder("Enter your email...")
 * email!: string;
 * ```
 */
export function Placeholder(text: string): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).placeholder = text;
  };
}

/**
 * Sets a description or help text for a field.
 *
 * @param text - The description text
 * @example
 * ```typescript
 * @Description("We'll never share your email with anyone")
 * email!: string;
 * ```
 */
export function Description(text: string): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).description = text;
  };
}

// =============================================================================
// Numeric Constraint Decorators
// =============================================================================

/**
 * Sets the minimum allowed value for a numeric field.
 *
 * @param value - The minimum value
 * @example
 * ```typescript
 * @Min(0)
 * quantity!: number;
 * ```
 */
export function Min(value: number): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).min = value;
  };
}

/**
 * Sets the maximum allowed value for a numeric field.
 *
 * @param value - The maximum value
 * @example
 * ```typescript
 * @Max(100)
 * percentage!: number;
 * ```
 */
export function Max(value: number): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).max = value;
  };
}

/**
 * Sets the step increment for a numeric field.
 *
 * @param value - The step value
 * @example
 * ```typescript
 * @Step(0.01)
 * price!: number;
 * ```
 */
export function Step(value: number): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).step = value;
  };
}

// =============================================================================
// String Constraint Decorators
// =============================================================================

/**
 * Sets the minimum length for a string field.
 *
 * @param value - The minimum character count
 * @example
 * ```typescript
 * @MinLength(1)
 * name!: string;
 * ```
 */
export function MinLength(value: number): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).minLength = value;
  };
}

/**
 * Sets the maximum length for a string field.
 *
 * @param value - The maximum character count
 * @example
 * ```typescript
 * @MaxLength(255)
 * bio!: string;
 * ```
 */
export function MaxLength(value: number): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).maxLength = value;
  };
}

/**
 * Sets a regex pattern for string validation.
 *
 * @param regex - The regex pattern as a string
 * @example
 * ```typescript
 * @Pattern("^[a-z]+$")
 * username!: string;
 * ```
 */
export function Pattern(regex: string): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).pattern = regex;
  };
}

// =============================================================================
// Array Constraint Decorators
// =============================================================================

/**
 * Sets the minimum number of items for an array field.
 *
 * @param value - The minimum item count
 * @example
 * ```typescript
 * @MinItems(1)
 * tags!: string[];
 * ```
 */
export function MinItems(value: number): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).minItems = value;
  };
}

/**
 * Sets the maximum number of items for an array field.
 *
 * @param value - The maximum item count
 * @example
 * ```typescript
 * @MaxItems(10)
 * tags!: string[];
 * ```
 */
export function MaxItems(value: number): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).maxItems = value;
  };
}

// =============================================================================
// Enum and Options Decorators
// =============================================================================

/**
 * Normalizes enum options input to a consistent array format.
 * Supports both array format and record shorthand.
 */
function normalizeEnumOptions(input: EnumOptionsInput): EnumOptionValue[] {
  if (Array.isArray(input)) {
    return input;
  }
  // Convert record { id: label } to array of { id, label } objects.
  // Note: Object.entries() preserves insertion order for non-integer-like string keys.
  // Integer-like keys (e.g. "0", "1") are ordered numerically ahead of other keys
  // per JS property enumeration rules, so numeric-looking ids may not appear in
  // pure insertion order.
  return Object.entries(input).map(([id, label]) => ({ id, label }));
}

/**
 * Provides custom options for enum fields with labels.
 *
 * Use this to provide human-readable labels for enum values,
 * or to customize the order and display of options.
 *
 * @param options - Array of options, or a record mapping ids to labels
 * @example
 * ```typescript
 * // Array format
 * @EnumOptions([
 *   { id: "us", label: "United States" },
 *   { id: "ca", label: "Canada" }
 * ])
 * country!: "us" | "ca";
 *
 * // Record shorthand
 * @EnumOptions({ us: "United States", ca: "Canada" })
 * country!: "us" | "ca";
 * ```
 */
export function EnumOptions(options: EnumOptionsInput): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).options = normalizeEnumOptions(options);
  };
}

// =============================================================================
// Conditional and Layout Decorators
// =============================================================================

/**
 * Makes a field conditionally visible based on another field's value.
 *
 * @param condition - Object specifying the field and value to match
 * @example
 * ```typescript
 * @ShowWhen({ field: "contactMethod", value: "email" })
 * emailAddress!: string;
 *
 * @ShowWhen({ field: "contactMethod", value: "phone" })
 * phoneNumber!: string;
 * ```
 */
export function ShowWhen(condition: ShowWhenCondition): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).showWhen = condition;
  };
}

/**
 * Groups fields together under a named section.
 *
 * @param name - The group name
 * @example
 * ```typescript
 * @Group("Personal Information")
 * @Label("First Name")
 * firstName!: string;
 *
 * @Group("Personal Information")
 * @Label("Last Name")
 * lastName!: string;
 *
 * @Group("Contact Details")
 * @Label("Email")
 * email!: string;
 * ```
 */
export function Group(name: string): PropertyDecorator {
  return function (target: object, propertyKey: string): void {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const ctor = target.constructor as new (...args: any[]) => any;
    getFieldMetadata(ctor, propertyKey).group = name;
  };
}

// =============================================================================
// Runtime API
// =============================================================================

/**
 * The name of the static property containing type metadata.
 * This is set by the `formspec codegen` command at build time.
 */
const FORMSPEC_TYPES_KEY = "__formspec_types__";

/**
 * Tracks which classes have been warned about missing type metadata.
 * This prevents duplicate warnings for the same class.
 */
const warnedClasses = new WeakSet();

/**
 * Emits a warning when a decorated class is used without type metadata.
 *
 * @param ctor - The class constructor
 * @param functionName - Name of the function that was called
 */
function warnIfMissingTypeMetadata(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ctor: new (...args: any[]) => any,
  functionName: string
): void {
  // Skip if already warned
  if (warnedClasses.has(ctor)) {
    return;
  }

  // Check if class has type metadata
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
  const hasTypeMetadata = FORMSPEC_TYPES_KEY in ctor && Object.keys((ctor as any)[FORMSPEC_TYPES_KEY] as object).length > 0;
  if (hasTypeMetadata) {
    return;
  }

  // Check if class has decorator metadata (indicating decorators were applied)
  // Safe to use non-null assertion: we just checked has(ctor)
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  const hasDecoratorMetadata = decoratorMetadata.has(ctor) && decoratorMetadata.get(ctor)!.size > 0;
  if (!hasDecoratorMetadata) {
    return; // No decorators applied, likely intentional basic usage
  }

  // Mark as warned and emit warning
  warnedClasses.add(ctor);

  const className = ctor.name || "UnknownClass";
  console.warn(
    `[FormSpec] Warning: ${functionName}(${className}) called without type metadata.\n` +
    `  - All fields will default to type "text"\n` +
    `  - All fields will be marked as required\n` +
    `  - Enum options from TypeScript types will not be available\n\n` +
    `  To fix this, run: formspec codegen <your-file.ts> -o ./__formspec_types__.ts\n` +
    `  Then import the generated file BEFORE calling ${functionName}():\n\n` +
    `    import './__formspec_types__';\n` +
    `    import { ${functionName} } from '@formspec/decorators';\n` +
    `    const schemas = ${functionName}(${className});\n`
  );
}

/**
 * Maps type metadata type to FormSpec field type.
 */
function mapTypeToFieldType(type: string): string {
  switch (type) {
    case "string":
      return "text";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "enum":
      return "enum";
    case "array":
      return "array";
    case "object":
      return "object";
    default:
      return "text";
  }
}

/**
 * Creates a FormSpec field from type and decorator metadata.
 */
function createField(
  fieldName: string,
  typeInfo: TypeMetadata,
  decoratorInfo: FieldDecoratorMetadata
): FormSpecField {
  const field: FormSpecField = {
    _field: mapTypeToFieldType(typeInfo.type),
    id: fieldName,
  };

  // Required if not optional and not nullable
  // Explicitly set to false for optional fields for consistency
  field.required = !typeInfo.optional && !typeInfo.nullable;

  // Apply decorator metadata
  if (decoratorInfo.label) field.label = decoratorInfo.label;
  if (decoratorInfo.placeholder) field.placeholder = decoratorInfo.placeholder;
  if (decoratorInfo.description) field.description = decoratorInfo.description;
  if (decoratorInfo.min !== undefined) field.min = decoratorInfo.min;
  if (decoratorInfo.max !== undefined) field.max = decoratorInfo.max;
  if (decoratorInfo.step !== undefined) field.step = decoratorInfo.step;
  if (decoratorInfo.minLength !== undefined)
    field.minLength = decoratorInfo.minLength;
  if (decoratorInfo.maxLength !== undefined)
    field.maxLength = decoratorInfo.maxLength;
  if (decoratorInfo.minItems !== undefined)
    field.minItems = decoratorInfo.minItems;
  if (decoratorInfo.maxItems !== undefined)
    field.maxItems = decoratorInfo.maxItems;
  if (decoratorInfo.pattern) field.pattern = decoratorInfo.pattern;
  if (decoratorInfo.showWhen) field.showWhen = decoratorInfo.showWhen;
  if (decoratorInfo.group) field.group = decoratorInfo.group;

  // Options: prefer decorator options, fall back to type values
  if (decoratorInfo.options) {
    field.options = decoratorInfo.options;
  } else if (typeInfo.values) {
    // Auto-generate { id, label } objects from type values
    field.options = typeInfo.values.map((v) => {
      const strVal = String(v);
      return { id: strVal, label: strVal };
    });
  }

  // Handle nested object properties
  if (typeInfo.type === "object" && typeInfo.properties) {
    field.fields = Object.entries(typeInfo.properties).map(
      ([propName, propType]) => createField(propName, propType, {})
    );
  }

  return field;
}

/**
 * Generates a UI Schema from a decorated class at runtime.
 *
 * **Requirements:**
 * - Run `formspec codegen` to generate type metadata for the class
 * - Decorators must be applied to store field metadata
 *
 * @param ctor - The class constructor
 * @returns FormSpec output with elements array
 *
 * @example
 * ```typescript
 * import { Label, toFormSpec } from '@formspec/decorators';
 *
 * class MyForm {
 *   @Label("Name")
 *   name!: string;
 *
 *   @Label("Country")
 *   country!: "us" | "ca";
 * }
 *
 * const spec = toFormSpec(MyForm);
 * // { elements: [{ _field: "text", id: "name", label: "Name", required: true }, ...] }
 * ```
 */
export function toFormSpec(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ctor: new (...args: any[]) => any
): FormSpecOutput {
  // Warn if decorated class is missing type metadata
  warnIfMissingTypeMetadata(ctor, "toFormSpec");

  // Get type metadata from codegen (if available)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
  const typeMetadata: Record<string, TypeMetadata> = (ctor as any)[FORMSPEC_TYPES_KEY] ?? {};

  // Get decorator metadata
  const classDecoratorMeta = decoratorMetadata.get(ctor) ?? new Map();

  // Combine to create elements
  const elements: FormSpecField[] = [];

  // Process all fields from type metadata
  for (const [fieldName, typeInfo] of Object.entries(typeMetadata)) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const decoratorInfo = classDecoratorMeta.get(fieldName) ?? {};
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    elements.push(createField(fieldName, typeInfo, decoratorInfo));
  }

  // If no type metadata, fall back to decorator metadata only
  // (limited functionality - no type information)
  if (Object.keys(typeMetadata).length === 0) {
    // Map.entries() can return types that ESLint infers as any in some contexts
    for (const [fieldName, decoratorInfo] of classDecoratorMeta.entries()) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      elements.push(createField(fieldName, { type: "unknown" }, decoratorInfo));
    }
  }

  return { elements };
}

/**
 * Gets the raw decorator metadata for a class.
 *
 * Useful for debugging or custom processing.
 *
 * @param ctor - The class constructor
 * @returns Map of field names to decorator metadata
 */
export function getDecoratorMetadata(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ctor: new (...args: any[]) => any
): Map<string, FieldDecoratorMetadata> {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-return
  return decoratorMetadata.get(ctor) ?? new Map();
}

/**
 * Gets the raw type metadata for a class.
 *
 * Useful for debugging or custom processing.
 *
 * @param ctor - The class constructor
 * @returns Record of field names to type metadata, or empty object if not transformed
 */
export function getTypeMetadata(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ctor: new (...args: any[]) => any
): Record<string, TypeMetadata> {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access
  return (ctor as any)[FORMSPEC_TYPES_KEY] ?? {};
}

// =============================================================================
// Schema Generation
// =============================================================================

/**
 * Maps FormSpecField type to JSON Schema type.
 */
function fieldTypeToJsonSchemaType(fieldType: string): string {
  switch (fieldType) {
    case "text":
      return "string";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "enum":
      return "string";
    case "array":
      return "array";
    case "object":
      return "object";
    default:
      return "string";
  }
}

/**
 * Converts a FormSpecField to JSON Schema.
 */
function fieldToJsonSchema(field: FormSpecField): JSONSchema7 {
  const schema: JSONSchema7 = {};

  if (field.label) {
    schema.title = field.label;
  }

  const jsonType = fieldTypeToJsonSchemaType(field._field);
  schema.type = jsonType;

  // Number constraints
  if (field.min !== undefined) schema.minimum = field.min;
  if (field.max !== undefined) schema.maximum = field.max;

  // String constraints
  if (field.minLength !== undefined) schema.minLength = field.minLength;
  if (field.maxLength !== undefined) schema.maxLength = field.maxLength;
  if (field.pattern) schema.pattern = field.pattern;

  // Enum options
  if (field._field === "enum" && field.options) {
    const hasLabels = field.options.some(
      (opt): opt is { id: string; label: string } =>
        typeof opt === "object" && "id" in opt
    );
    if (hasLabels) {
      schema.oneOf = field.options.map((opt) => {
        if (typeof opt === "object" && "id" in opt) {
          return { const: opt.id, title: opt.label };
        }
        // opt is a string in this case
        return { const: opt, title: opt };
      });
    } else {
      schema.enum = field.options.map((opt) =>
        typeof opt === "string" ? opt : (opt as { id: string }).id
      );
    }
  }

  // Array items
  if (field._field === "array" && field.fields) {
    const itemProperties: Record<string, JSONSchema7> = {};
    const itemRequired: string[] = [];
    for (const nested of field.fields) {
      itemProperties[nested.id] = fieldToJsonSchema(nested);
      if (nested.required) itemRequired.push(nested.id);
    }
    schema.items = {
      type: "object",
      properties: itemProperties,
      ...(itemRequired.length > 0 && { required: itemRequired }),
    };
    if (field.minItems !== undefined) schema.minItems = field.minItems;
    if (field.maxItems !== undefined) schema.maxItems = field.maxItems;
  }

  // Object properties
  if (field._field === "object" && field.fields) {
    const objProperties: Record<string, JSONSchema7> = {};
    const objRequired: string[] = [];
    for (const nested of field.fields) {
      objProperties[nested.id] = fieldToJsonSchema(nested);
      if (nested.required) objRequired.push(nested.id);
    }
    schema.properties = objProperties;
    if (objRequired.length > 0) schema.required = objRequired;
  }

  return schema;
}

/**
 * Generates JSON Schema from FormSpecField elements.
 */
function generateJsonSchemaFromElements(elements: FormSpecField[]): JSONSchema7 {
  const properties: Record<string, JSONSchema7> = {};
  const required: string[] = [];

  for (const element of elements) {
    properties[element.id] = fieldToJsonSchema(element);
    if (element.required) {
      required.push(element.id);
    }
  }

  return {
    $schema: "https://json-schema.org/draft-07/schema#",
    type: "object",
    properties,
    ...(required.length > 0 && { required }),
  };
}

/**
 * Converts a field name to a JSON Pointer scope.
 */
function fieldToScope(fieldName: string): string {
  return `#/properties/${fieldName}`;
}

/**
 * Converts FormSpecField elements to UI Schema elements.
 */
function elementsToUiSchema(elements: FormSpecField[]): UISchemaElement[] {
  const result: UISchemaElement[] = [];

  for (const element of elements) {
    const control: UISchemaElement = {
      type: "Control",
      scope: fieldToScope(element.id),
    };

    if (element.label) {
      control.label = element.label;
    }

    // Add conditional visibility rule
    if (element.showWhen) {
      control.rule = {
        effect: "SHOW",
        condition: {
          scope: fieldToScope(element.showWhen.field),
          schema: { const: element.showWhen.value },
        },
      };
    }

    result.push(control);
  }

  return result;
}

/**
 * Generates UI Schema from FormSpecField elements.
 * Groups consecutive fields with the same @Group decorator into JSON Forms Group layouts.
 * Preserves field order, creating multiple Group elements if the same group name
 * appears in non-consecutive positions.
 */
function generateUiSchemaFromElements(elements: FormSpecField[]): UISchemaElement {
  const uiElements: UISchemaElement[] = [];
  let currentGroup: string | undefined = undefined;
  let currentGroupElements: UISchemaElement[] = [];

  function flushCurrentGroup(): void {
    if (currentGroupElements.length === 0) return;

    if (currentGroup === undefined) {
      // Ungrouped fields go directly into the layout
      uiElements.push(...currentGroupElements);
    } else {
      // Grouped fields are wrapped in a Group element
      uiElements.push({
        type: "Group",
        label: currentGroup,
        elements: currentGroupElements,
      });
    }
    currentGroupElements = [];
  }

  for (const element of elements) {
    // Safe to use non-null assertion: elementsToUiSchema always returns at least one element
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const control = elementsToUiSchema([element])[0]!;
    const groupName = element.group;

    if (groupName !== currentGroup) {
      // Flush the previous group and start a new one
      flushCurrentGroup();
      currentGroup = groupName;
    }

    currentGroupElements.push(control);
  }

  // Flush any remaining group
  flushCurrentGroup();

  return {
    type: "VerticalLayout",
    elements: uiElements,
  };
}

/**
 * Builds both JSON Schema and UI Schema from a decorated class at runtime.
 *
 * This function provides the same API as `buildFormSchemas` from `@formspec/build`,
 * allowing consistent usage across both Chain DSL and Decorator DSL.
 *
 * **Requirements:**
 * - Run `formspec codegen` to generate type metadata for the class
 * - Decorators must be applied to store field metadata
 *
 * @param ctor - The class constructor
 * @returns Object containing both jsonSchema and uiSchema
 *
 * @example
 * ```typescript
 * import { Label, buildFormSchemas } from '@formspec/decorators';
 *
 * class MyForm {
 *   @Label("Name")
 *   name!: string;
 *
 *   @Label("Country")
 *   country!: "us" | "ca";
 * }
 *
 * // After running: formspec codegen ./forms.ts -o ./__formspec_types__.ts
 * // And importing: import './__formspec_types__';
 *
 * const { jsonSchema, uiSchema } = buildFormSchemas(MyForm);
 * // jsonSchema: { $schema: "...", type: "object", properties: {...}, required: [...] }
 * // uiSchema: { type: "VerticalLayout", elements: [...] }
 * ```
 */
export function buildFormSchemas(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ctor: new (...args: any[]) => any
): BuildResult {
  // Warn if decorated class is missing type metadata
  // (toFormSpec will also check, but we want the correct function name in the warning)
  warnIfMissingTypeMetadata(ctor, "buildFormSchemas");

  const { elements } = toFormSpec(ctor);

  return {
    jsonSchema: generateJsonSchemaFromElements(elements),
    uiSchema: generateUiSchemaFromElements(elements),
  };
}
