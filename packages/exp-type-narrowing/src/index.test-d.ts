/**
 * tsd type tests for type narrowing experiments
 *
 * These tests verify that TypeScript correctly narrows types
 * in various scenarios related to the fetchOptions contract.
 */

import { expectType, expectError } from "tsd";
import type {
  FieldParameterMap,
  FetchOptionsRequest,
  FetchOptionsRequestUnion,
  FormState,
} from "./types.js";

// =============================================================================
// Test: FetchOptionsRequest generic maintains correlation
// =============================================================================

// FetchOptionsRequest now requires two type params: K and Params extends FieldParameterMap[K]
declare function createRequest<
  K extends keyof FieldParameterMap,
  Params extends FieldParameterMap[K],
>(
  field: K,
  parameters: Params
): FetchOptionsRequest<K, Params>;

// Correct usage: template_id with fragment parameter
const templateIdRequest = createRequest("template_id", { fragment: "search" });
expectType<FetchOptionsRequest<"template_id", { fragment: string }>>(templateIdRequest);

// Correct usage: template_vars with empty object
// Note: {} infers as {} not Record<string, never>, but both are compatible with the constraint
const templateVarsRequest = createRequest("template_vars", {});
expectType<FetchOptionsRequest<"template_vars", {}>>(templateVarsRequest);

// Error: wrong parameter type for field
expectError(createRequest("template_id", { wrong: "param" }));

// Error: template_vars shouldn't accept fragment
expectError(createRequest("template_vars", { fragment: "search" }));

// =============================================================================
// Test: Discriminated union narrows correctly
// =============================================================================

declare const unionRequest: FetchOptionsRequestUnion;

if (unionRequest.field === "template_id") {
  // After narrowing, parameters should have fragment
  expectType<{ fragment?: string }>(unionRequest.parameters);
}

if (unionRequest.field === "template_vars") {
  // After narrowing, parameters should be Record<string, never>
  expectType<Record<string, never>>(unionRequest.parameters);
}

// =============================================================================
// Test: Switch narrowing on discriminated union
// =============================================================================

function testSwitchNarrowing(request: FetchOptionsRequestUnion) {
  switch (request.field) {
    case "template_id":
      expectType<{ fragment?: string }>(request.parameters);
      break;
    case "template_vars":
      expectType<Record<string, never>>(request.parameters);
      break;
    case "crm_object":
      expectType<{ fragment?: string }>(request.parameters);
      break;
    case "field_mapping":
      expectType<Record<string, never>>(request.parameters);
      break;
  }
}
void testSwitchNarrowing;

// =============================================================================
// Test: Generic function does NOT narrow (demonstrating the limitation)
// =============================================================================

function testGenericNoNarrow<F extends keyof FieldParameterMap>(
  field: F,
  parameters: FieldParameterMap[F]
) {
  // Even after checking field, parameters stays as FieldParameterMap[F]
  // This is the expected limitation of the generic approach
  if (field === "template_id") {
    // parameters is still FieldParameterMap[F], not { fragment?: string }
    // We can only access properties common to all parameter types (none)
    expectType<FieldParameterMap[F]>(parameters);
  }
}
void testGenericNoNarrow;

// =============================================================================
// Test: Handler map provides correct typing per field
// =============================================================================

type FieldHandlerMap = {
  [F in keyof FieldParameterMap]: (
    formState: FormState<Record<string, unknown>>,
    parameters: FieldParameterMap[F]
  ) => void;
};

declare const handlers: FieldHandlerMap;

// Each handler gets correctly typed parameters
const _templateIdHandler = handlers.template_id;
expectType<
  (
    formState: FormState<Record<string, unknown>>,
    parameters: { fragment?: string }
  ) => void
>(_templateIdHandler);

const _templateVarsHandler = handlers.template_vars;
expectType<
  (
    formState: FormState<Record<string, unknown>>,
    parameters: Record<string, never>
  ) => void
>(_templateVarsHandler);

// =============================================================================
// Test: Union type auto-generation from FieldParameterMap
// =============================================================================

type AutoGeneratedUnion = {
  [F in keyof FieldParameterMap]: {
    field: F;
    parameters: FieldParameterMap[F];
  };
}[keyof FieldParameterMap];

// Should be equivalent to manually defining the union
type ManualUnion =
  | { field: "template_id"; parameters: { fragment?: string } }
  | { field: "template_vars"; parameters: Record<string, never> }
  | { field: "crm_object"; parameters: { fragment?: string } }
  | { field: "field_mapping"; parameters: Record<string, never> };

// Type-level equality check
declare const autoGenerated: AutoGeneratedUnion;
expectType<ManualUnion>(autoGenerated);

declare const manual: ManualUnion;
expectType<AutoGeneratedUnion>(manual);
